# Problem Summary

<table><thead><tr><th width="40">#</th><th width="156.80169677734375">Problem</th><th width="362.104248046875">Intuition</th><th>Solution Links</th></tr></thead><tbody><tr><td>1</td><td>Longest Increasing Subsequence</td><td><p>Recursive: </p><ol><li>Start with 0, -1.</li><li>If an element in the index is greater than the previous one, include it or skip the element.</li><li>Find max(include and exclude).</li><li>Base: index == len(nums), return 0.</li></ol></td><td><a href="longest-increasing-subsequence.md#id-1.-recursive-approach">Solution</a></td></tr><tr><td></td><td></td><td>Tabulation DP: </td><td><a href="longest-increasing-subsequence.md#id-2.-tabulation-dynamic-programming-dp">Solution</a></td></tr><tr><td></td><td></td><td>Memoization DP: </td><td><a href="longest-increasing-subsequence.md#id-3.-memoization-dynamic-programming-dp">Solution</a></td></tr><tr><td>2</td><td>Number of Longest Increasing Subsequence</td><td>Recursive: Intuition based on counting the number of subsequences that can be formed.</td><td>Solution</td></tr><tr><td></td><td></td><td>Tabulation DP: Use a table to count the number of subsequences ending at each index.</td><td></td></tr><tr><td></td><td></td><td>Memoization DP: Optimize the recursive approach using memoization.</td><td></td></tr></tbody></table>
