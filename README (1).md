---
cover: .gitbook/assets/ChatGPT Image Mar 31, 2025, 06_02_09 PM.png
coverY: 0
---

# Leet Code Intutions

<table><thead><tr><th width="40">#</th><th width="156.80169677734375">Problem</th><th width="343.3883056640625">Intuition</th><th>Solution Links</th></tr></thead><tbody><tr><td>1</td><td><a href="https://leetcode.com/problems/longest-increasing-subsequence/">Longest Increasing Subsequence</a></td><td><p>Recursive: </p><ol><li>Start with 0, -1.</li><li>If an element in the index is greater than the previous one, include it or skip the element.</li><li>Find max(include and exclude).</li><li>Base: index == len(nums), return 0.</li></ol></td><td><a href="longest-increasing-subsequence.md#id-1.-recursive-approach">Solution</a></td></tr><tr><td></td><td></td><td><p>Tabulation DP:  (Optimized)</p><ol><li>Start with each element as a subsequence of length 1 in a [].</li><li>For each element in the sequence, look for pre elements and if the current element is greater than prev ele then update [].</li><li>The Max element in list is Longest subsequence. </li></ol></td><td><a href="longest-increasing-subsequence.md#id-3.-tabulation-dynamic-programming-dp">Solution</a></td></tr><tr><td></td><td></td><td><p>Memoization DP:   </p><ol><li>Avoid recalculation and initialize a Dict. </li><li> Fill the dict with the Longest sequence up to the point. </li></ol></td><td><a href="longest-increasing-subsequence.md#id-2.-memoization-dynamic-programming-dp">Solution</a></td></tr><tr><td>2</td><td><a href="https://leetcode.com/problems/target-sum/">Target Sum</a></td><td><p>Recursive:  </p><ol><li>start with current_sum =0</li><li><p>For each number in the list:</p><ol><li>you can either ADD(+)</li><li>Or Subtract (-)</li></ol></li><li>When Curr_Sum == Target then return 1 else, return 0</li><li> return the total of ADD+Subtract; this would be the "total number of Targeted sum."</li></ol></td><td>Solution</td></tr><tr><td></td><td></td><td><p>Memoization DP:   </p><ol><li>Avoid recalculation and initialize a Dict. </li><li> Fill the dict with the (index,curr_sum) = ADD+Subtract.</li><li>Now return the Dict[ (index,curr_sum)]</li></ol></td><td></td></tr><tr><td></td><td></td><td> Tabulation DP: </td><td></td></tr><tr><td>3</td><td><a href="https://leetcode.com/problems/house-robber/">House Robber</a></td><td><p>Recursive:  </p><ol><li><p>Base case:</p><ol><li>when the index is 0 you will return nums[index] (only one house to rob)</li><li>when the index is less than 0 return 0 (Invalid case, No house)</li></ol></li><li><p>Start with the end of the list. When you go for an index you can include or exclude </p><ol><li>Include = element at the index + f(index -2) (skip the adjacent house)</li><li>Exclude = 0 + f(index -1)  (Skip the current house and check the previous one)</li></ol></li><li>return the maximum(include, exclude) </li></ol></td><td><a href="house-robber.md#id-1.-recursive-approach">Solution</a></td></tr><tr><td></td><td></td><td><p>Memoization DP:</p><ol><li>To avoid re-calculation, Use an array/dict to keep track of the maximum at that index.</li><li>When the index is in Dict, return the memo[index] value.</li></ol></td><td><a href="house-robber.md#id-2.-memoization-dynamic-programming-dp">Solution</a></td></tr><tr><td></td><td></td><td><p>Tabulation DP: </p><ol><li>We fill a DP array </li><li>Dp[i] stores a max money robbed until that house.</li><li><p>At each step, we can decide to include or exclude the current house.</p><ol><li>Include: adding money from <code>i-2</code> since adjacent houses can't be robbed.</li><li>Exclude : taking the value from <code>dp[i-1]</code> .</li></ol></li><li>return last element from Dp array.</li></ol></td><td><a href="house-robber.md#id-3.-tabulation-dynamic-programming-dp">Solution</a></td></tr><tr><td></td><td></td><td><p>Space optimized : </p><ol><li><p>Let's use </p><ol><li>prev as the first element in the list.</li><li>prev2 as 0</li></ol></li><li><p>with the same bottom-up approach but without storing results in an array.</p><ol><li>include = curr_element and if index is greater than 1 add prev2.</li><li>exclude = prev</li><li>curr_max = max(include, exclude)</li><li>Swap prev to prev2, curr_max to prev.</li></ol></li><li>Return prev.</li></ol><p></p></td><td><a href="house-robber.md#id-4.-space-optimzed-dp">Solution</a></td></tr><tr><td>4</td><td><a href="https://leetcode.com/problems/house-robber-ii/">House Robber II</a> <br><mark style="color:red;">S</mark><em><mark style="color:red;">ame as House Robber</mark></em> </td><td><p></p><p>Recursive<br>Memoization DP <br>Tabulation DP<br>Space optimized :  </p><ol><li><p>Just divide the array into </p><ol><li>array[1:] ( 0 element not included)</li><li>array[:-1] (Last element not included)</li></ol></li></ol></td><td><a href="problem-summary/house-robber-ii.md#house-robber-ii">Solution</a></td></tr><tr><td>5</td><td><a href="https://leetcode.com/problems/best-time-to-buy-and-sell-stock-with-transaction-fee/">Best Time to Buy and Sell Stock with Transaction Fee</a></td><td><p>Space Optimized : </p><ol><li>start with initializing buy , sell to zero</li><li><p>Start from last element : </p><ol><li>buy if max(buy, sell - day_price )</li><li>sell if max(sell, buy + price -fee)</li></ol></li><li>return buy -> holds the maximum profit without holding a stock at the end.</li></ol></td><td><a href="problem-summary/best-time-to-buy-and-sell-stock-with-transaction-fee.md#id-4.-space-optimized-dp">Solution</a> </td></tr><tr><td></td><td></td><td></td><td></td></tr></tbody></table>

